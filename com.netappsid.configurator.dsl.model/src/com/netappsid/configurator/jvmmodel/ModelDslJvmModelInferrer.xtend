/*
 * generated by Xtext 2.9.1
 */
package com.netappsid.configurator.jvmmodel

import com.google.inject.Inject
import com.netappsid.configurator.modelDsl.Attribute
import com.netappsid.configurator.modelDsl.Configurable
import com.netappsid.configurator.modelDsl.DynamicEnum
import com.netappsid.configurator.modelDsl.Enum
import com.netappsid.configurator.modelDsl.Property
import java.util.logging.Level
import java.util.logging.Logger
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.compiler.XbaseCompiler
import org.eclipse.xtext.xbase.compiler.output.ITreeAppendable
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor.IPostIndexingInitializing
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class ModelDslJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	@Inject XbaseCompiler xBaseCompiler
	@Inject Logger logger

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the closure you pass to the returned
	 *            {@link IPostIndexingInitializing#initializeLater(org.eclipse.xtext.xbase.lib.Procedures.Procedure1)
	 *            initializeLater(..)}.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch infer(Enum configurable, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(configurable.toClass(configurable.fullyQualifiedName))[]
	}

	def dispatch infer(DynamicEnum configurable, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(configurable.toClass(configurable.fullyQualifiedName))[]
	}

	def dispatch infer(Configurable configurable, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(configurable.toClass(configurable.fullyQualifiedName)) [ inferredClass |
			try {
				generateConfigurable(configurable, inferredClass)
			} catch (Exception e) {
				logger.throwing("ModelDslJvmModelinferrer", "infer", e);
				logger.log(Level.SEVERE, e.message, e)
			}
		]

	}

	def private generateConfigurable(Configurable configurable, JvmGenericType inferredClass) {
		// Sanity check. Let's make sure the Configurable class exists
		val superType = configurable.superType

//			inferredClass.superTypes += (if (superType == null)
//				typeRef("com.netappsid.erp.configurator2.Configurable")
//			else
//				superType.cloneWithProxies)
		// Abstract configurable
		inferredClass.abstract = configurable.abstract;

		// Generate fields with properties
		configurable.properties.forEach [ prop |
			val propertyType = typeRef("com.bc360.configurator.property.impl.ValueProperty", prop.type)

			inferredClass.members += configurable.toField(prop.name, propertyType) [
				simpleName = prop.name
				visibility = JvmVisibility.PRIVATE
				final = true
				setInitializer[append('''new «propertyType.simpleName»("«prop.name»")''')]
			]
		]

		// Generate init() method
		inferredClass.members += configurable.toMethod('init', typeRef(Void::TYPE)) [
			body = [ appender |
				configurable.properties.forEach [ prop |
					if (prop.attributes !== null) {
						prop.attributes.forEach[inferAttributeInit(prop, appender)]
					}
				]
			]
		]
	}

	def inferAttributeInit(Attribute att, Property prop, ITreeAppendable it) {
		append(prop.name)
//		switch att.name {
//			case 'VALUE':
//				append('.setValue(')
//			case 'DEFAULT_VALUE':
//				append('.setDefaultValue(')
//			default: {
//				//val attributeType = typeRef("com.bc360.configurator.property.PropertyAttribute")
//				
//				append('''.setAttribute(«attributeType.type.simpleName».«att.name», ''')
//			}
//		}
		
		append('''.setAttribute(«att.name», ''')
		xBaseCompiler.toJavaExpression(att.expression, it)

		append(');')
		newLine
	}
}
